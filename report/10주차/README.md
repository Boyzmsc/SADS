# 캡스톤 10주차 보고서

## 1. 발전된 SADS의 동작 실험 내용

동작 실험용 데이터로 송신기와 수신기에서 **25632**의 랜덤 시드를 이용해 동일한 값의 시간 배열을 생성하고 해당 배열의 요소 값에 따라 광고 패킷을 송수신하여 **2000개**의 사용자의 광고 패킷만을 **10개**의 파일로 수집했습니다. 이후 실험용 스푸핑 공격 데이터를 생성하기 위해 별도의 데이터 생성 모듈을 만들어 공격자의 광고 패킷을 사용자의 광고 패킷 사이에 삽입했습니다. 동작 실험 및 성능 평가 항목으로는,

* 공격자의 광고 패킷이 없다는 가정 하에 모델 동작
  * 사용자의 광고 패킷을 스푸핑 공격으로 감지하는 FN (= False Negative) 검증
  * False Alarm의 수치가 낮을 수록 제대로 동작하는 것임

* 공격자의 광고 패킷이 있다는 가정 하에 모델 동작
  * 공격자의 광고 패킷을 스푸핑 공격으로 감지하는 TN (= True Negative) 검증
  * 공격자의 광고 패킷은 송신하는 시점부터 특정 간격 (= 광고 패킷 송신 간격)으로 계속해서 송신된다고 가정
  * 100%의 정확도로 감지한다고 예상하고 동작 실험 진행
  * 결과 값이 1 이상이면 Spoofing Attack을 감지할 수 있다는 뜻

<br />

## 2. 발전된 SADS의 동작 실험 결과

|                | File 1 | File 2 | File 3 | File 4 | File 5 | File 6 | File 7 | File 8 | File 9 | File 10 |
| -------------- | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------- |
| **True Negative**  | 701    | 762    | 1003   | 701    | 664    | 701    | 709    | 633    | 693    | 701     |
| **False Negative** | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0      | 0       |

<br />

## 3. 랜덤 약속 시간 리스트를 사용하는 SADS의 문제점

발전된 SADS 모델은 랜덤 시드를 이용해 송신기와 수신기 측에서 동일한 값의 시간 배열을 생성하고, 배열 요소 값에 따라 광고 패킷을 송수신하거나 송수신하지 않음으로써 일대일 통신이 이루어지게 됩니다. 앞선 SADS 모델의 동작 실험에서 저희의 예상과 동일한 결과값이 출력되어 성공적으로 실험이 진행되었음에도 불구하고 계속되는 모델의 동작 실험 도중 저희는 한가지 문제점을 발견할 수 있었습니다. 송신기와 수신기 사이의 통신이 길어지면 뒤이어 False Alarm이 발생하기 시작하더니 점차 뒤로 갈수록 해당 수치가 증가하는 것을 확인할 수 있었습니다. 해당 현상의 원인을 분석한 결과 아래와 같은 원인들을 발견할 수 있었습니다.

* **송신기와 수신기에서 실행되는 함수 실행시간의 차이**
  * 송신기는 Flutter로 개발
  * 수신기는 Python으로 개발
  * 서로 다른 두 언어로 개발된 코드에서 실행시간 차이에 따른 딜레이 발생
  * 이러한 딜레이가 통신 시간이 길어질수록 누적되어 일대일 통신의 규칙을 깸

* **송신기에서 송신된 광고 패킷이 수신기로 수신될 때의 발생하는 딜레이**
  * 송신기에서 방송되는 광고 패킷은 수신기에 수신되기까지 약 0.02초의 딜레이가 발생함
  * 또한 고정된 0.02초의 딜레이가 아닌 주변의 환경요소로 인해 가변적으로 딜레이가 발생함
  * 따라서 예측 불가능한 딜레이가 반복적으로 누적되어 결론적으로 일대일 통신의 규칙을 깸

<br />

## 4. Delay 문제를 해결하기 위한 Unicast Phase 시나리오

위와 같은 원인들로 인해 저희는 송신기와 수신기 사이의 딜레이를 의식하여 False Alarm의 수치를 줄일 수 있는 일대일 통신 시나리오를 아래와 같이 구상해 적용해 시스템에 적용해 보았습니다. 

![시나리오 적용 전](https://user-images.githubusercontent.com/28584213/167528245-d79c519f-3146-447d-858e-285754159acd.jpg)

위의 그림에서 파란색 선은 송신기와 수신기 사이의 광고 패킷을 송수신하는 **Promise Time**을 의미하고, 빨간색 선은 광고 패킷을 송수신하지 않는 **Non-promise Time**을 의미합니다. Tag에서 송신하는 광고 패킷은 약 0.02초의 시간 이후 Server로 수신됩니다. 따라서 **Promise Time**에 송신되는 광고 패킷은 **Non-promise Time** 상태인 Server에 수신되기 때문에 **False Alarm**으로 인식될 수 있는 가능성이 있습니다.

![시나리오 적용 후](https://user-images.githubusercontent.com/28584213/167528242-bea90842-a5f4-40fe-b2f3-17d7d0acfe2e.jpg)

따라서 저희는 위의 그림에서 초록색 선인 **유예 시간**을 시나리오에 추가함으로써 앞서 언급한 상황으로 인해 발생하는 **False Alarm**의 발생 빈도를 낮출 수 있었습니다. 하지만 결론적으로 해당 시나리오를 사용하더라도 근본적인 문제점을 해결할 수는 없었습니다.

<br />

## 5. 랜덤 약속 시간 리스트를 사용하는 SADS의 활용성의 문제

또한 실내 위치 측위를 사용하는 시스템이나 광고 패킷을 분석하는 시스템에서는 광고 패킷을 실시간으로 수신하고 데이터를 처리해야하지만, 위와 같이 **Promise Time**과 **Non-promise Time** 상태를 계속해서 바꾸는 SADS 모델에서는 실시간으로 데이터를 수신하지 못하기 때문에 **Real-Time Based 시스템**에서는 활용할 수 없는 문제점 또한 확인할 수 있었습니다.

<br />

## 6. 문제점의 해결 방안

현재의 SADS 모델은 송신기와 수신기 사이의 일대일 통신을 위해 사용자의 광고 패킷을 먼저 필터링하고 스푸핑 공격을 탐지합니다. 하지만 이러한 시스템 시퀀스는 스푸핑 공격이 발생하지 않는 상황에서도 동작하기 때문에 **Unicast Phase** 단계에서 **Promise Time**과 **Non-promise Time**이 무분별하게 변경되어 위와 같은 문제점이 발생하게 욉니다. 따라서 저희는 전체 SADS 모델의 동작 시퀀스를 역전시키는 방안을 구상했습니다. 즉, 스푸핑 공격 탐지를 먼저 수행한 뒤 일대일 통신을 통해 사용자의 광고 패킷을 필터링하는 시퀀스로 변경합니다. 이에 따라 스푸핑 공격 검사가 먼저 동작되며, 해당 단계에서 공격을 감지하지 못하는 경우는 공격자와 사용자 사이의 거리가 매우 가까이 위치한 경우 뿐이기 때문에 이러한 경우에만 일대일 통신을 통해 스푸핑 공격을 감지하고 공격자의 광고 패킷을 특정할 수 있습니다.

<br />

## 7. 수정한 동작 시퀀스의 기대 효과

* 스푸핑 공격 탐지 단계가 선행으로 실행되기 때문에 공격자와 사용자 사이의 거리가 매우 가까운 경우를 제외하면 높은 탐지 정확도를 보임 (= **Detection Phase**)

* Detection Phase에서 공격자와 사용자 사이의 거리가 매우 가까울 때만 일대일 통신 (= **Unicast Phase**)으로 넘어가기 때문에 **Promise Time**과 **Non-promise Time**을 무분별하게 이용할 필요가 없어짐

* **Unicast Phase**에서도 무분별하게 **Promise Time**과 **Non-promise Time**을 사용하는 것이 아니라 단 한번의 **Non-promise Time**으로 공격자의 광고 패킷을 탐지하고 구분할 수 있기 때문에 앞서 언급한 딜레이의 누적 문제를 해결할 수 있다고 판단함

* 또한 **Unicast Phase** 단계에서 **Promise Time**과 **Non-promise Time**이 무분별하게 변경되지 않으며 **Detection Phase**부터 탐지 수행이 이루어지기 때문에 **Real-Time Based 시스템**에서도 활용할 수 있다고 판단함